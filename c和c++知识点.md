## c/c++基础

### static关键字有什么用？

- 修饰局部变量，使得在静态存储区分配内存，只能在函数首次调用中进行首次初始化，作用域依旧是局部作用域
- 修饰全局变量，使得该变量在静态存储区分配存储，在整个文件中可见
- 修饰函数，在整个文件中可见，可以避免多人协作时避免同名函数的冲突
- 静态成员变量：c++才有
- 静态成员函数：c++才有

### 什么是静态成员变量？

​    将类成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区

- 静态成员变量

- - 最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。
    - 无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。
    - 非静态成员类外不能初始化。
    - 静态成员数据是共享的。

### 什么是静态成员函数？

​    将类成员函数声明为static，则为静态成员函数。

- 静态成员函数

- - 静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。
    - 普通成员函数可以访问普通成员变量，也可以访问静态成员变量。
    - 静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问静态变量成员，也没有this指针。

### volatile有什么用？

​    volatile字面意思可变的，被它修饰的变量表示可以被某些编译器未知的原因更改，编译器访问这个变量时不会在优化，常用在多线程间被几个任务共享的变量。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化。

### #define与const有什么不同？

1. 编译时期不同：define在预处理阶段展开，const在编译阶段使用
2. 安全检查同：define宏没有安全检查，而const是有具体类型，会执行类型检查
3. 定义域不同：define宏不受定义域限制，而const只在定义域内有效
4. 存储方式不同：define宏不会给分派内存，而const会分配，但也只是维持一份拷贝

### 变量的声明和定义有什么区别？

​    声明：不分配地址空间；可以多次声明

​    定义：为变量分配地址空间；只能定义一次，加入extern修饰的是变量的声明，说明此变量在文件外或文件后定义。

### 简述#ifdef、#else、#endif和#ifndef的作用

​    这些统称为条件编译，这几个配合使用可以防止头文件的重复包含和编译，并且便于程序的调试和移植。

### sizeof和strlen区别

​    sizeof为操作符，计算占内存的字节数大小，不同的计算机或编译器下不一定相同；编译期就算出了结果。

​    strlen为库函数，计算一个以'\0'结尾的字符串的实际长度；必须运行才能算出结果。

### 简述strcpy、sprintf与memcpy区别：

- 操作对象不同：两个操作对象都是字符串；源对象可以是多种类型，目的对象是字符串；两个内存地址。
- 执行效率不同：memcpy>strcpy>sprintf
- 实现功能不同：字符串拷贝；其他类型到字符串的转换；内存拷贝。

### 简述内联函数inline的优缺点：

- 优点：在调用地方进行代码展开，省去调用函数事件，提高了程序的效率；并且会进行安全类型检查。内联函数比较适合用在频繁使用且内容不多的地方。
- 缺点：代码膨胀，产生更多的函数；如果内联函数执行时间比调用事件长很多，提升的效率也不高；修改麻烦，修内联所有调用的地方都需要重新编译。

### 智能指针分为哪几种？各自有什么特点？

​    智能指针是一个RAII资源获取即初始化类模型，用于动态分配内存，智能指针的作用是能够处理内存泄漏和空悬指针问题。分为四种：

- auto_ptr，实现所有权的概念，被抛弃了，由于对象所有权问题，不能指向数组，不能作为STL的成员；
- shard_ptr，实现共享式拥有的概念，多个智能指针可以同时指向该对象；
- weak_ptr，为了解决shared_prt相互引用时引用永远不会变为0而导致的死锁问题，不控制对象生命周期的指针；
- unique_ptr，实现独占式拥有的概念，同一时间只能由一个智能指针指向该对象。

### 右值引用有什么作用？

​    右值引用作为参数的目的是实现转移语义，而作为返回值的意义是完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数。

### 悬挂指针和野指针有什么区别？

- 悬挂指针是指当对象被释放，但是该指针没有任何改变，指向了被回收的内存
- 野指针：未被初始化的指针

### 指针和引用的区别？

- 指针有自己的地址空间，引用只是一个别名
- sizeof(指针)为4，sizeof(引用)为引用对象的大小
- 有const指针，没有const引用
- 如果返回动态分配的对象或者内存，必须使用指针，引用会引起内存泄露
- 引用必须初始化，而指针而不一定

### typedef和define的区别

- 用法不同：typedef用作给一种数据类型外号，增强程序可读性；define宏主要就是定义常量
- 执行时间不同：typedef是编译过程中的一部分，进行类型检查；define是预编译部分，不进行类型检查
- 作用域不同：：typedef有作用域限定，define不受作用域约束
- 对指针操作不同：typedef如果对指针进行封装，无论后面有多少变量都会被声明为指针；而define只会将后面的第一个声明变为指针

### C语言的结构体和C++的类有什么区别？

- 修饰不一样：结构体全部都是public修饰，类可以指定public、private与protected三种修饰符
- 默认修饰也不一样：结构体默认就是public，类不指明的话默认是private
- 结构体不能有成员函数，类可以有
- 结构体没有继承，类有继承

### extern  C有什么作用？

​    extern C主要的作用就是正确实现在C++代码中调用其他C语言代码，加上这段代码，编译器会按照C语言的编译方式来对这段代码进行编译。

### 面向对象的三大特征：

- 封装：将客观事物封装为类，而类可以很好的隐藏自己的信息
- 继承：可以使用现有的类所有功能，并且无需重新编写就可以对原来的类进行拓展
- 多态：一个类实例的相同方法在不同情况下有不同的表现形式

### 多态的实现方式：

- 动态多态：虚函数、继承，执行动态绑定，在运行期间确定
- 静态多态：重载、模板，指定静态绑定，在编译期间确定

### 动态绑定是如何实现的？

​    编译器发现有虚函数时，会创建一张虚函数表，把虚函数的入口地址放在虚函数表中，并且在对象中增加一个vptr虚函数指针，用于指向虚函数表，当派生类覆盖基类的虚函数时，会将虚函数指针进行替换，从而调用派生后覆盖的的虚函数，从而实现动态绑定。

​    虚函数表是针对类的，类的所有对象共享这个虚函数表，每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象vptr指针的地址不一样，但是都指向同一虚函数表。

### 动态绑定有什么作用？有哪些必要条件？

作用：

- 隐藏实现细节，使代码模块化，提高复用性
- 接口重用，是派生类功能可以被基类指针/引用所调用，即向后兼容

必要条件：

- 继承
- 虚函数
- 需要基类指针/引用指向子类对象

### 为什么基类的构造函数不能定义为虚函数？

​    虚函数的调用依赖虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。

### 为什么基类的析构函数要定义为虚函数？

​    为了实现动态绑定，基类指针指向派生类，如果析构不是虚函数，那么会实现静态绑定，在删除基类指针时只会调用基类的析构函数，而不会调用派生类的析构函数，只能销毁基类对象中的数据部分，所以必须将析构函数定义为虚函数。

### 构造函数和析构函数可以抛出异常么？

- 构造函数可以，但是不好，会导致内存泄漏
- 析构函数不可以，如果析构时抛出异常，异常点之后的程序不会执行，一些释放资源的语句不会被执行，会导致内存泄漏，而且一般发生异常时，对象会调用自己的析构函数来释放资源，如果在析构函数中在抛出异常，会造成程序崩溃。

### 如果不让一个类实例化？

- 纯虚函数
- 将构造函数定义为private

### 多继承存在什么问题？如何消除多继承中的二义性？

多继承存在的问题：

- 程序复杂，维护困难
- 在继承时，如果基类之间或者基类与派生类之间发生成员同名时，会出现对成员访问的不确定，造成同名二义性
- 当派生类从多个基类派生，而这些基类又从同一个基类派生（菱形继承），则在访问此共同基类的成员时将会产生不确定性，即路径二义性；菱形继承另外一个缺点就是冗余性：存在在重复的数据。

消除同名二义性：

- 利用作用域运算符::，限定派生类使用哪个基类的成员
- 在派生类中定义同名成员，覆盖基类相关成员

消除路径二义性：

- 同名那两个都可以
- 使用虚继承，使不同路径继承来的同名成员在内存中只有一份拷贝

### 覆盖和重载的区别：

- 覆盖：派生类中重新定义基类中的函数，其函数名、参数列表、返回值与父类完全相同，指示函数体存在区别，覆盖只发生在类的成员函数中
- 重载：是指两个具有相同名字的函数，有不同的参数列表，不关心返回值

### 类怎么防止继承？

- 可以将类变为一个内部类
- 可以将构造函数设置为private
- 可以在Class前使用关键字final

### c++中四种强制类型转换

- reinterpret_cast<type-id\> (expression) 可以用于不同类型指针之间或引用之间强制转化
- const_cast (expression)，该运算符用来修改类型的const或volatile属性，一般用在修改底指针
- static_cast<type-id\> (expression)强转类型，用于基本数据之间的类型转换，子类向父类的安全转换，void*于其他指针类型的转换，没有运行时类型检查保证转换的安全性。
- dynamic_cast (expression)有类型检查，基类向派生类转换比较安全(向下转化)，派生类向基类转化不太安全(向上转化)，并且可以使虚基类向子类转化；在向下转化时，对于非法的指针返回NULL，对于引用返回bad_cast异常

### new/delete和malloc/free之间有什么关系

- new与delete直接带具体数据类型，malloc和free返回void类型的指针
- new类型是安全的，malloc不是
- new调用构造函数，malloc不能；delete调用析构函数，free不能
- malloc/free需要库文件stdlib.h支持，new/delete则不需要

​    **ps：delete和free调用后，内存不会立刻回收，指针也不会指空，释放完内存应该让指针指向NULL。**

### delete与delete []的区别？

- 对于简单类型来说，new分配以后调用两个都可以释放内存
- 对于自定义类型而言，需要对单个对象使用delete，对数组对象使用delete []
- 最恰当的方式是如果new一个对象，就delete它，如果new []对象，就delete []

### 内存泄漏的场景有哪些？

- malloc/free没有成对使用，new/delete没有成对出现
- 在堆中创建对象分配内存，但是未显式释放内存；比如通过局部分配的内存，未在调用者函数体内释放
- 在构造函数内动态分配内存，没有在析构函数中正确释放
- 未定义拷贝构造函数或未重载负载运算符。从而造成两次释放相同的内存
- 没有将基类的析构函数定义为虚函数

### 内存的分配方式有几种？

- 从栈上分配：局部变量
- 从堆上分配：new分配的内存如果编译器不管就会被应用进程控制
- 从自由存储区分配：c++通过new和delete动态分配和释放对象的抽象概念，与堆不等价
- 从常量存储区分配：存放常量，不可修改
- 从全局/静态存储区分配：全局变量和静态变量被分派带同一块内存

### 内存模型

<img src="C:\Users\zhuzhibo\AppData\Roaming\Typora\typora-user-images\image-20230313081843766.png" alt="image-20230313081843766" style="zoom:80%;" />

​    从上到下为高地址到低地址，分四个区：

- 堆区，从高字节向低字节存储，主要存放new和malloc的对象，一般由程序员释放
- 栈区，从低字节向高字节存储，主要存放局部变量，一般由编译器释放
- 全局区：主要包含静态全局区和常量区
- 代码区：存放函数体的二进制代码

### 堆和栈有什么区别？

- 分配和管理方式不同：堆是动态分配；栈是编译器自动管理
- 产生碎片不同：对于堆来说，频繁使用new/delete会造成内存空间的不连续，产生大量碎片；对栈来说，不存在碎片问题，后进先出
- 生长方向不同：堆是向着内存地址增长的方向增长，由内存低地址到高地址方向增长；栈正好相反
- 申请大小限制不同：堆是不连续的区域，大小可以灵活调整；栈的栈顶和栈底都是预设好的，大小固定

#### 深拷贝与浅拷贝有什么区别？

- 浅拷贝是将原对象或原数组的引用直接赋给新对象或新数组，新的只是原来的一个引用，新旧对象还是共享一块内存
- 深拷贝是创建一个新的对象和数组，将原对象的各项属性的“值”(数组的所有元素)拷贝过来，是值而不是引用，新旧对象不共享一块内存，修改新对象不会对旧对象发生影响

### 什么是字节对齐？原则是什么？

​    字节对齐是字节按照一定规则在空间上排列。原则如下：

- 从偏移为0的位置开始存储
- 基本数据类型对齐：基本数据类型自身占用的存储空间大小

### 结构体字节对齐的问题：

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同
- 未特殊说明。按结构体中size最大的成员对齐
- 结构体分配的总空间大小必须是最宽基本类型成员的整数倍
- 结构体各个成员相对结构体起始地址的偏移量是该成员数据类型大小的整数倍
- 如果没有定义 `#pragma pack(n)` ，sizeof的最后结果必然是结构体内部最大成员的整数倍，不够补齐，结构体内各个成员的首地址必然是自身大小的整数倍
- 如果定义了`#pragma pack(n)` ，sizeof的结果最后必然是min[n, 结构体内最大成员的整数倍]，不够补齐，结构体内内部各个成员的首地址必然是min[n, 自身大小]的整数倍

### 友元是什么？

​    某个类需要实现某种功能，但是这个类自身由于某些原因无法自己实现，需要借助外力才能实现，就是友元函数。友元函数friend允许一个类授权其他类访问他的非公有成员，只能出现在类的声明中，他们不受类中public、private和protected的影响。

