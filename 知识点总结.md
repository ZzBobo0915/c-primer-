## c/c++基础知识点

### c/c++代码到可执行二进制文件的过程：

- 预编译：展开所有头文件、宏置换、去掉注释、条件编译、添加行号和文件名标识；得到一个 `.i` 的文件  
- 编译：进行词法、语法、语义分析，代码优化等；使用g++或gcc编译预处理过的 `.i` 文件，得到一个 `.s` 文件
- 汇编：将代码 `.s` 汇编成机器指令 `.o` 文件
- 链接：将不同`.o` 文件与静态库或动态库进行链接，形成可执行程序 `.exe`

### 硬链接、软链接

​    `ln [选项] 源文件 目标文件` 创建链接，选项中是 `-s` 就是创建软连接，否则就是硬链接

- 硬链接：实际上是文件的一个别名，只能引用同一系统中的文件，他引用的是文件的inode，当移动或删除原文件时，硬链接不会被破坏；硬链接不允许链接目录文件。
- 软链接：又叫符号链接，和原文件不是一个文件，类似windows的快捷方式；如果原始文件被删除，所有指向他的符号链接也就被破坏，有自己的inode；可以跨越文件系统链接，也可以为目录建立链接。

### 动态库与静态库

​    库文件的命名一般都是 `libxxx.so  libxxx.a` ，真实名字一般都是去掉 `lib` 与 `.a-  .so-`后缀剩下的名字。

- 静态库：编译时，把库文件的代码全部加入到可执行文件中，因此生成的文件较大，但在运行时就不再需要库文件了，后缀名一般为 `.a`
- 动态库：在编译连接时并没有把库文件代码加入可执行文件中，而是在程序执行时由运行时链接文件加载库文件加载库，这样可以节省系统的开销，后缀名一般为 `.so`

### gdb常用指令

- `gdb xxx` 执行xxx可执行文件
- `l` list 默认显示10行代码，回车继续10行
- `b 10` break 在10行打断点
- `r` run 开始运行，直到断点
- `n` next 执行当前语句，如果为函数调用，不会进入函数
- `s` step 执行当前语句，如果为函数调用，进入函数执行第一条语句
- `p name` print 显示变量名name的值
- `c` continue 继续运行，直到断点
- `set var name="zhuzhibo"`  改变变量值

### static关键字有什么用？

- 修饰局部变量，使得在静态存储区分配内存，编译时赋初值且只能赋值一次，作用域依旧是局部作用域，但是函数结束后依然存在，只不过不能被其他函数调用
- 修饰全局变量，使得该变量在静态存储区分配存储，在整个文件中可见
- 修饰函数，在整个文件中可见，可以避免多人协作时避免同名函数的冲突
- 静态成员变量：c++才有
- 静态成员函数：c++才有

### 什么是静态成员变量？

​    将类成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区

- 静态成员变量

- 最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。
  
    无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。
  
    非静态成员类外不能初始化。
  
    静态成员数据是共享的。

### 什么是静态成员函数？

​    将类成员函数声明为static，则为静态成员函数。

- 静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。
      -普通成员函数可以访问普通成员变量，也可以访问静态成员变量。
      -静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。

### volatile有什么用？

​    volatile字面意思可变的，被它修饰的变量表示可以被某些编译器未知的原因更改，编译器访问这个变量时不会在优化，常用在多线程间被几个任务共享的变量。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化。

### #define与const有什么不同？

1. 编译时期不同：define在预处理阶段展开，const在编译阶段使用
2. 安全检查同：define宏没有安全检查，而const是有具体类型，会执行类型检查
3. 定义域不同：define宏不受定义域限制，而const只在定义域内有效
4. 存储方式不同：define宏不会给分派内存，而const会分配，但也只是维持一份拷贝

### 变量的声明和定义有什么区别？

​    声明：不分配地址空间；可以多次声明

​    定义：为变量分配地址空间；只能定义一次，加入extern修饰的是变量的声明，说明此变量在文件外或文件后定义。

### 简述#ifdef、#else、#endif和#ifndef的作用

​    这些统称为条件编译，这几个配合使用可以防止头文件的重复包含和编译，并且便于程序的调试和移植。

### sizeof和strlen区别

​    sizeof为操作符，计算占内存的字节数大小，不同的计算机或编译器下不一定相同；编译期就算出了结果。

​    strlen为库函数，计算一个以'\0'结尾的字符串的实际长度；必须运行才能算出结果。

### 简述strcpy、sprintf与memcpy区别：

- 操作对象不同：两个操作对象都是字符串；源对象可以是多种类型，目的对象是字符串；两个内存地址。
- 执行效率不同：memcpy>strcpy>sprintf
- 实现功能不同：字符串拷贝；其他类型到字符串的转换；内存拷贝。

### 简述内联函数inline的优缺点：

- 优点：在调用地方进行代码展开，省去调用函数时间，提高了程序的效率；并且会进行安全类型检查。内联函数比较适合用在频繁使用且内容不多的地方。
- 缺点：代码膨胀，产生更多的函数；如果内联函数执行时间比调用事件长很多，提升的效率也不高；修改麻烦，修内联所有调用的地方都需要重新编译。

### 智能指针分为哪几种？各自有什么特点？

​    智能指针是一个RAII资源获取即初始化类模型，用于动态分配内存，智能指针的作用是能够处理内存泄漏和空悬指针问题。分为四种：

- auto_ptr，实现所有权的概念，被抛弃了，由于对象所有权问题，不能指向数组，不能作为STL的成员；
- shared_ptr，实现共享式拥有的概念，多个智能指针可以同时指向该对象；该对象和其相关资源会在“最后一个引用被销毁”时候释放。使用reset()放弃内部对象的所有权或拥有对象的变更。
- weak_ptr，实现了弱共享、弱引用的 概念，为了解决shared_prt相互引用时引用永远不会变为0而导致的死锁问题，依赖shared_ptr生存，只能由一个shared_ptr 或另一个 weak_ptr 对象构造
- unique_ptr，实现独占式拥有的概念，同一时间只能由一个智能指针指向该对象。

### 右值引用有什么作用？

​    右值引用作为参数的目的是实现转移语义，而作为返回值的意义是完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数。

- 左值引用：可以去取地址的，有名字的，非临时的
- 右值引用：no取地址的，没名字的，临时的

### 悬挂指针和野指针有什么区别？

- 悬挂指针是指当对象被释放，但是该指针没有任何改变，指向了被回收的内存
- 野指针：未被初始化的指针

### 指针和引用的区别？

- 指针有自己的地址空间，引用只是一个别名
- sizeof(指针)为4，sizeof(引用)为引用对象的大小，sizeof(空的类型)大小为1
- 有const指针，没有const引用
- 如果返回动态分配的对象或者内存，必须使用指针，引用会引起内存泄露
- 引用必须初始化，而指针而不一定

### typedef和define的区别

- 用法不同：typedef用作给一种数据类型外号，增强程序可读性；define宏主要就是定义常量
- 执行时间不同：typedef是编译过程中的一部分，进行类型检查；define是预编译部分，不进行类型检查
- 作用域不同：：typedef有作用域限定，define不受作用域约束
- 对指针操作不同：typedef如果对指针进行封装，无论后面有多少变量都会被声明为指针；而define只会将后面的第一个声明变为指针

### C语言的结构体和C++的类有什么区别？

- 修饰不一样：结构体全部都是public修饰，类可以指定public、private与protected三种修饰符
- 默认修饰也不一样：结构体默认就是public，类不指明的话默认是private
- 结构体不能有成员函数，类可以有
- 结构体没有继承，类有继承

### extern  C有什么作用？

​    extern C主要的作用就是正确实现在C++代码中调用其他C语言代码，加上这段代码，编译器会按照C语言的编译方式来对这段代码进行编译。

### 面向对象的三大特征：

- 封装：将客观事物封装为类，而类可以很好的隐藏自己的信息
- 继承：可以使用现有的类所有功能，并且无需重新编写就可以对原来的类进行拓展
- 多态：一个类实例的相同方法在不同情况下有不同的表现形式

### 多态的实现方式：

- 动态多态：虚函数、继承，执行动态绑定，在运行期间确定
- 静态多态：重载、模板，指定静态绑定，在编译期间确定

### 动态绑定是如何实现的？

​    编译器发现有虚函数时，会创建一张虚函数表，把虚函数的入口地址放在虚函数表中，并且在对象中增加一个vptr虚函数指针，用于指向虚函数表，当派生类覆盖基类的虚函数时，会将虚函数指针进行替换，从而调用派生后覆盖的的虚函数，从而实现动态绑定。

​    虚函数表是针对类的，类的所有对象共享这个虚函数表，每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象vptr指针的地址不一样，但是都指向同一虚函数表。

### 动态绑定有什么作用？有哪些必要条件？

作用：

- 隐藏实现细节，使代码模块化，提高复用性
- 接口重用，是派生类功能可以被基类指针/引用所调用，即向后兼容

必要条件：

- 继承
- 虚函数
- 需要基类指针/引用指向子类对象

### 为什么基类的构造函数不能定义为虚函数？

​    虚函数的调用依赖虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。

### 为什么基类的析构函数要定义为虚函数？

​    为了实现动态绑定，基类指针指向派生类，如果析构不是虚函数，那么会实现静态绑定，在删除基类指针时只会调用基类的析构函数，而不会调用派生类的析构函数，只能销毁基类对象中的数据部分，所以必须将析构函数定义为虚函数。

### 构造函数和析构函数可以抛出异常么？

- 构造函数可以，但是不好，会导致内存泄漏
- 析构函数不可以，如果析构时抛出异常，异常点之后的程序不会执行，一些释放资源的语句不会被执行，会导致内存泄漏，而且一般发生异常时，对象会调用自己的析构函数来释放资源，如果在析构函数中在抛出异常，会造成程序崩溃。

### 如果不让一个类实例化？

- 纯虚函数
- 将构造函数定义为private

### 多继承存在什么问题？如何消除多继承中的二义性？

多继承存在的问题：

- 程序复杂，维护困难
- 在继承时，如果基类之间或者基类与派生类之间发生成员同名时，会出现对成员访问的不确定，造成同名二义性
- 当派生类从多个基类派生，而这些基类又从同一个基类派生（菱形继承），则在访问此共同基类的成员时将会产生不确定性，即路径二义性；菱形继承另外一个缺点就是冗余性：存在在重复的数据。

消除同名二义性：

- 利用作用域运算符::，限定派生类使用哪个基类的成员
- 在派生类中定义同名成员，覆盖基类相关成员

消除路径二义性：

- 同名那两个都可以
- 使用虚继承，使不同路径继承来的同名成员在内存中只有一份拷贝

### 覆盖和重载的区别：

- 覆盖：派生类中重新定义基类中的函数，其函数名、参数列表、返回值与父类完全相同，指示函数体存在区别，覆盖只发生在类的成员函数中
- 重载：是指两个具有相同名字的函数，有不同的参数列表，不关心返回值

### 类怎么防止继承？

- 可以将类变为一个内部类
- 可以将构造函数设置为private
- 可以在Class前使用关键字final

### c++中四种强制类型转换

- reinterpret_cast<type-id\> (expression) 可以用于不同类型指针之间或引用之间强制转化
- const_cast (expression)，该运算符用来修改类型的const或volatile属性，一般用在修改底层指针
- static_cast<type-id\> (expression)强转类型，用于基本数据之间的类型转换，子类向父类的安全转换，void*与其他指针类型的转换，没有运行时类型检查保证转换的安全性。
- dynamic_cast (expression)有类型检查，基类向派生类转换比较安全(向下转化)，派生类向基类转化不太安全(向上转化)，并且可以使虚基类向子类转化；在向下转化时，对于非法的指针返回NULL，对于引用返回bad_cast异常

### new/delete和malloc/free之间有什么关系

- new与delete直接带具体数据类型，malloc和free返回void类型的指针
- new类型是安全的，malloc不是
- new调用构造函数，malloc不能；delete调用析构函数，free不能
- malloc/free需要库文件stdlib.h支持，new/delete则不需要

​    **ps：delete和free调用后，内存不会立刻回收，指针也不会指空，释放完内存应该让指针指向NULL。**

### delete与delete []的区别？

- 对于简单类型来说，new分配以后调用两个都可以释放内存
- 对于自定义类型而言，需要对单个对象使用delete，对数组对象使用delete []
- 最恰当的方式是如果new一个对象，就delete它，如果new []对象，就delete []

### 内存泄漏的场景有哪些？

- malloc/free没有成对使用，new/delete没有成对出现
- 在堆中创建对象分配内存，但是未显式释放内存；比如通过局部分配的内存，未在调用者函数体内释放
- 在构造函数内动态分配内存，没有在析构函数中正确释放
- 未定义拷贝构造函数或未重载赋值运算符。从而造成两次释放相同的内存
- 没有将基类的析构函数定义为虚函数

### 内存泄露怎么避免

- 使用智能指针
- malloc/free new/delete一一对应
- 尽量资源获取即初始化 RAII

### c++的内存的分配方式

- 从栈上分配：局部变量，一般由编译器创建释放
- 从堆上分配：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free()可把内存交还
- 自由存储区：是C++中通过new和delete动态分配和释放对象的抽象概念，过new来申请的内存区域可称为自由存储区。（为c+特有的，c，没有这一块）
- 从常量存储区分配：存放常量，不可修改
- 从全局/静态存储区分配：全局变量和静态变量被分派带同一块内存（c中全局和静态变量分为初始化和未初始化的，在c++中无区分共用同一块内存）

### 内存模型

​    从上到下为高地址到低地址，分四个区：

- 栈区，从低字节向向字节存储，主要存放局部变量，一般由编译器释放
- 堆区，从高字节向低字节存储，主要存放new和malloc的对象，一般由程序员释放
- 全局区：主要包含静态全局区和常量区
- 代码区：存放函数体的二进制代码

### 堆和栈有什么区别？

- 分配和管理方式不同：堆是动态分配；栈是编译器自动管理
- 产生碎片不同：对于堆来说，频繁使用new/delete会造成内存空间的不连续，产生大量碎片；对栈来说，不存在碎片问题，后进先出
- 生长方向不同：堆是向着内存地址增长的方向增长，由内存低地址到高地址方向增长；栈正好相反
- 申请大小限制不同：堆是不连续的区域，大小可以灵活调整；栈的栈顶和栈底都是预设好的，大小固定

### 深拷贝与浅拷贝有什么区别？

- 浅拷贝是将原对象或原数组的引用直接赋给新对象或新数组，新的只是原来的一个引用，新旧对象还是共享一块内存
- 深拷贝是创建一个新的对象和数组，将原对象的各项属性的“值”(数组的所有元素)拷贝过来，是值而不是引用，新旧对象不共享一块内存，修改新对象不会对旧对象发生影响

### 什么是字节对齐？原则是什么？

​    字节对齐是字节按照一定规则在空间上排列。原则如下：

- 从偏移为0的位置开始存储
- 基本数据类型对齐：基本数据类型自身占用的存储空间大小

### 结构体字节对齐的问题：

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同
- 未特殊说明。按结构体中size最大的成员对齐
- 结构体分配的总空间大小必须是最宽基本类型成员的整数倍
- 结构体各个成员相对结构体起始地址的偏移量是该成员数据类型大小的整数倍
- 如果没有定义 `#pragma pack(n)` ，sizeof的最后结果必然是结构体内部最大成员的整数倍，不够补齐，结构体内各个成员的首地址必然是自身大小的整数倍
- 如果定义了`#pragma pack(n)` ，sizeof的结果最后必然是min[n, 结构体内最大成员的整数倍]，不够补齐，结构体内内部各个成员的首地址必然是min[n, 自身大小]的整数倍

### 友元是什么？

​    某个类需要实现某种功能，但是这个类自身由于某些原因无法自己实现，需要借助外力才能实现，就是友元函数。友元函数friend允许一个类授权其他类访问他的非公有成员，只能出现在类的声明中，他们不受类中public、private和protected的影响，并且友元关系不能够传递，只对类内声明友元的类有效。

## STL知识点

### STL序列式容器有哪些？

- array：数组，固定大小数组，支持快速随机访问，不能插入删除元素
- vector：动态数组，支持快速随机访问，尾部插入删除元素速度快
- list：双向链表，只支持双向顺序访问，任何位置插入删除都很快
- deque：双向队列，支持快读随机访问，首尾插入和删除的速度很快
- forward_list：单向链表，只支持单项顺序访问，任何位置插入删除速度都很快

### array底层原理

​    array本质就是一个**大小固定的数组**，无法动态改变，只允许访问或替换数组中的元素。

### vector底层原理

​    vector底层是一个**动态数组**，包含三个迭代器，start, finish, end_of_storage；当数组空间装不下时，会自动申请另一篇更大的空间（1.5倍或2倍），把原来的数据拷贝带新的内存空间，然后释放原来的那片空间。

​    vector调用clear()函数只是清空了里面的数据，其存储空间不释放。

### vector中reserver与resize

​    vector中reverse()是直接扩充到确定的大小下，可以减少多次开辟、释放空间的问题；resize()可以改变有效空间的大小，也有改变默认值的功能。

### vector中size与capacity

​    vector中size表示当前有多少元素，capacity表示当前分配的内存能容纳多少元素。

### 如何正确释放vector内存

- vec.clear(); vec.shrink_to_fit();  清空内容并且释放内存
- vector(Vec).swap(Vec); 清除内存
- vector().swap(Vec); 清除内存

### list底层原理

​    list底层是一个**双向链表**，以节点为单位存储数据，节点的地址在内存中不一定连续，每次插入或者删除一个元素，就配置或释放一个元素空间。

​    list不支持随机存取，适合需要大量的插入和删除，而不关心随机存取的应用场景。

### deque底层原理

​    deque底层是一个**双向开口的线性连续空间（双端队列**），在头部和尾部插入、删除元素有理想的复杂度；并且deque也不保证存储元素所有元素都存储在连续的空间内。

### vector、list与deque都适用于什么情况？

​    vector可以随机存储元素，不需要挨个查找，适合随机存取的场景使用，除非必要情况尽量都使用vecter而非deque；

​    list适用于对象大、对象数量频繁变化，插入和删除频繁的场景；

​    deque适合在头尾两端进行操作的场景。

### forwrad_list底层原理

​    froward_list和list差不多，只不过他是一个**单向链表**，节点的地址在内存中不一定连续。

### STL关联容容器是什么？有哪些？

​    关联式容器是指存储元素是会为元素配备一个键Key，整体以键值对的方式存储在容器中；另外，关联式容器在存储元素时会根据元素的大小进行排序(less<T\>, greater<T\>)。

- map：关联数组，key-value
- multimap：key可重复出现的map
- set：只保存关键字
- multiset：key可重复出现的set

### 上述几个关联式容器的的底层原理是什么？

​    关联式容器的底层都是根据**红黑树**实现的，epoll模型的低层也是红黑树。红黑树具有以下特点：

1. 是一个棵平衡二叉树
2. 节点分为两种颜色：红色和黑色
3. 根节点和叶子节点为黑色
4. 红色结点的子节点必须是黑色节点
5. 根节点到任意一个叶子节点的路径上黑色节点个数相同

### map

​    map容器存储的都是pair对象（键值对），默认情况下会自定根据键的大小按照升序排序std::less<T\>。map中存储的键不能重复也不能被修改（注意是键不能修改！值可以）。

### multimap

​    multimap与map一样按照键值对存储，不相同的是multimap可以存入多个相同键的键值对。

### set

​    与两个map容器不同，使用set容器存储的各个键值对的key和value都相等。set还要求存储的键不能重复，并且默认情况下也会根据键的大小按升序排序。

### multeset

​     multiset与set一样按照键值对存储key和value都相等，不同的是multiset可以存入多个相同的键值对。

### map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？

​    map和set的插入删除速度都是logN。

​    由于红黑树存储的是节点，不需要内存拷贝和内存移动，插入和删除操作也只是将节点的指针换来换去，节点内存没有改变。

### 为何map和set不能像vector一样有个reserve函数来预分配数据?

​    因为在map和set内部存储的已经不是元素本身了，而是包含元素的结点。也就是说map内部使用的Alloc并不是map<Key, Data, Compare, Alloc>声明的时候从参数中传入的Alloc。

### map的插入方式有几种？

- 用insert插入pair数据 `mapM.insert(pair<char, int>('a', 1));`
- 用insert插入value_type数据 `mapM.insert(map<char, int>::value_type('a', 1));`
- 在insert函数中使用make_pair()函数 `mapM.insert(make_pair('a', 1));`
- 用数组下标方式插入 `mapM['a'] = 1;`

### STL无序式关联容器有哪些？

​    无序式关联容器，又称哈希容器，采用的存储结构为哈希表。**哈希表可以根据关键字直接找到数据的存储位置，不需要进行任何比较，大大降低数据查找和存储消耗的时间，但是需要比较多的内存。**

- unordered_map
- unordered_set    
- unordered_multimap
- unordered_multiset 

### unordered_map底层原理、unordered_set底层原理

​    unordered_map的底层是一个防冗余的哈希表（采用除留余数法），还是采用键值对的方式存储，键值对互不相等并且不会对存储内容进行排序。

   unordered_set底层也是一个防冗余的哈希表，不以键值对存储，直接存储数据的值，元素值互不相同并且不会对内容进行排序。

​    使用一个下标范围较大的数组来存储元素，设计一个哈希函数(散列函数)，使得每一个元素的key都与一个函数值(数组下表，hash值)相对应，用这个数组单元来存储这个元素，这个数组单元也被成为桶。

​    对于不同元素计算出相同哈希值(即发生冲突)的时候，一般采用开链法解决冲突。

hash

### STL的容器适配器有哪些？

​    容器适配器是一个封装了序列容器的模板。

- stack
- queue
- priority_queue

### stack底层原理

​    stack适配器是一个**单端开口的容器**，模拟栈存储结构，无论存数据还是读数据，都只能从这个一个开口操作。满足后进先出LIFO准则。

### queue底层原理

​    queue适配器有**两个开口的容器，一个专门输入数据，一个专门输出数据**，模拟单向队列存储结构。满足先入先出FIFO准则。

### priority_queue底层原理

​    priority_queue适配器模拟的也是队列这种存储结构，只能一端进，另一段出，且每次访问只能访问队头元素，本质是一个堆，又被称为优先队列(最大堆/最小堆)，队头元素永远都是优先级最大的元素。可以在创建优先队列对象时指明是最大堆less<T\>还是最小堆greater<T\>，这里less与greater与其他容器不同，priority_queue默认最大堆。

### 迭代器失效

- vector删除当前的iterator会使后面所有元素的iterator都失效，erase会返回下一个有效的iterator，要采用 `iter = erase(iter)` 的方式删除。vector插入元素时，如果capacity不变（即不需要扩容），只有.end迭代器失效，如扩容则全部失效
- deque删除当前的iterator只会使当前的iterator失效，erase会返回下一个有效的iterator，要采用 ` erase(*iter)` 或 `erase(iter++)` 的方式删除；首尾插入元素不会使迭代器失效
- 关联式容器和list删除当前的iterator只会使当前的iterator失效，返回值为void，所以要采用 `erase(iter++)` 的方式来删除；插入元素不会使迭代器失效。

### lambda表达式

​    c++11引入的语法糖，在调用或作为函数参数传递的位置处定义匿名对象的便捷方式，包括：捕获列表、列表参数、可变规则、返回类型和函数体：

```c++
std::sort(x, x+n 
         [捕获列表] 这里写可变规则 (float a,  float b 参数列表) 这里写返回类型 {
             return  (std::abs(a) < std::abs(b));  函数体
         });
```

​    捕获列表中可以采用值传递或引用传递。[=]表示值传递捕获父作用域所有变量、[&]表示引用传递捕获父作用域所有对象、[this]表示捕获this指针。



## MySQL知识点

### MySQL的框架

​    主要由Server层和存储引擎两部分

​    Server：连接器，查询缓存，分析器，优化器，执行器；涵盖了MySQL的大多数核心服务功能

​    存储引擎负责：数据的存储与提取，支持MyISAM与InnoDB等

### 数据库的三范式

1. 第一范式：强调的是原子性，即数据库表的每一列都是不可分割的原子数据项
2. 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性
3. 第三范式：任何非主属性不依赖其他属性

### char和varchar的区别

- char(n)：固定长度类型；效率高，但是占用空间
- varchar(n)：可变长度，存储的值是每个值占的字节再加上一个用来记录其他长度的字节的长度

### 索引的理解

​    索引的出现是为了提高数据的查询效率，同样索引也会带来很多负担，创建索引和维护索引需要消耗时间，并且占据物理空间；同时会降低更新表的速度，因为更新表的时候不仅要保存数据，还需要保存索引文件。

​    建立索引的原则：

- 在最频繁使用的、用以缩小查询范围的字段上建立索引
- 在频繁使用的、需要排序的字段上建立索引

### B+树的理解

- B+树是基于B树和叶子节点顺序访问指针实现的，具有B树的平衡性，并且通过顺序访问指针提高区间查询的性能
- 在B+树中，一个节点的key从左到右非递减排列
- 进行查找操作，首先在根节点二分查找，找到一个key所在的指针，然后递归地在指针所指向的节点查找，直到找到叶子节点，然后再叶子节点上二分查找，找出key对应的data
- 插入、删除会破坏树的平衡性，因此插入删除之后需要对树进行操作维护平衡性

### B树与B+树的区别

- B+树叶子节点保存了完整的索引与数据，而非叶子节点只保留索引值，因此查询时间为O(logN)；而B树每个节点都保留索引和数据
- B+范围查找只需要遍历叶子节点链表，而B树却需要重复的中序遍历
- B+适合外部存储，因为非叶子节点不存储数据，只保存索引

### 索引的分类

- 从数据结构角度分析
    1. 树索引
    2. Hash索引
- 从物理存储角度看
    1. 聚簇索引
    2. 非聚簇索引
- 从逻辑角度看
    1. 普通索引
    2. 唯一索引
    3. 主键索引
    4. 联合索引
    5. 全文索引

### 聚簇索引与非聚簇索引

​    聚簇索引是磁盘上实际数据重新组织按照一个或多个列的值排序的算法，特点是存储数据的顺序和索引顺序一样。一般主键会默认创建聚簇索引，且一张表只能有一个聚簇索引。

​    非聚簇索引与聚簇索引的区别就是：聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍是索引节点，指向对应数据块的指针(指向聚簇索引)

### 哈希索引

​    哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效，可以O(1)的速度进行查找，但是失去了有序性，无法用于分组、排序，只能支持精确查找，无法用于部分和范围查找。

​    InnoDB有一种自适应哈希索引，当某个索引值被频繁使用时，在B+树的索引基础上会再创建一个哈希索引，这样就让B+树具有哈希索引的优点

### 逻辑角度的五个索引：

- 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。主要为以下三个：
    - 普通索引：MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值
    - 唯一索引：索引列的值必须唯一，但是允许为空值
    - 主键索引：是一种特殊的唯一索引，不允许有空值（主键约束，就是只能有一个主键索引）
- 联合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀原则
- 全文索引：只能在char\varvchar\text类型字段上使用的索引，在一堆文字中通过某个关键字就能找到该字段所属的行

### 最左前缀原则

​    MySQL使用联合索引时需要满足最左前缀原则，即最左优先，以最左边的为起点任何连续的索引都能匹配上：

- 如果第一个字段是范围查询需要单独建一个索引；
- 在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

​    最左前缀原则会一直向右匹配直到遇到查找范围(<，>，BETWEEN，LIKE)就停止匹配；并且=和IN可以乱序

### 什么情况不用索引

1. 索引列参与表达式计算
2. 函数运算
3. %语句%这种模糊查询
4. 字符串与数字比较
5. 查询条件中有OR
6. 正则表达式
7. 如果MySQL内部优化器估计扫描全表速度比索引快，就不会用索引

### InnoDB与MyISAM比较

- 事务：InnoDB支持，MyISAM不支持
- 全文索引：InnoDB5.6之前不支持，MyISAM支持
- 关于count()：MyISAM会直接存储总行数，InnoDB不会，需要按行扫描。对于 `SELECT count() FROM table;` 如果数据量较大，MyISAM会瞬间返回，而InnoDB会一行一行扫描
- 外键：InnoDB支持外键，MyISAM不支持
- 锁：InnoDB支持全局锁、表锁、行锁，MyISAM只支持全局锁和表锁

### 事务的定义

​    事务是一个最小的不可再分的工作单元，通常一个事务对应一个完整的义务。他有着四个特性：ACID：

### 事务的特性

​    ACID，即原子性、一致性、隔离性、持久性：

- 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保要么动作全部做完，要么完全不起作用
- 一致性（Consistency）：执行事务前后，数据库从一个一致性状态转移到另一个一致性状态
- 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
- 持久性（Durability）：一个事务被提交后，他对数据库中的数据的改变是永久的，即使数据库发生了故障也不应该对其有任何影响

### 事务隔离级别

1. 未提交读：最低的隔离级别，允许读取尚未提交的数据变更，可导致脏读、幻读、不可重复读
2. 提交读：允许读取并发事务已经提交的数据，可以防止脏读，但是幻读、不可重复读仍能发生
3. 可重复读：对同一字段的多次读取结果都是一致的，可以阻止脏读和不可重复读，但是幻读仍有可能发生
4. 串行化：最高隔离级别，完全符合ACID。可以防止脏读、幻读、不可重复读，但是执行效率有太低，影响程序性能，一般都不用。

### 什么是脏读、幻读、不可重复读

- 脏读：表示一个事务还未提交的数据能够被另一个事务获取。
- 不可重复读：一个事务内，多次读同一个数据，由于这个事务还没有结束，另外一个事务也访问这个数据，在第一个事务两次读取数据之间，第二个事务修改了数据，导致两次读取结果不一致，这就是不可重复读。（不可重复读在于修改：同样的条件，你读取过的数据再读出来就不一样了）
- 幻读：指同一事务内多次查询返回结果集不一样，比如事务A第一次查询有4条数据，第二次一样的查询却有2条，两次结果不一致，好像产生了幻觉，这就是幻读。（幻读在于新增或删除：同样的条件，第一次和第二次读出来的结果不一样）

### 全局锁、表锁、行锁

​    这个三个是按照锁粒度区分的：

- 全局锁：使用FTWRL `Flush tables with read lock` 对整个数据库实例进行加锁，是整个数据库处于只可读状态。
- 表锁： `lock tables ... read/write` `unlock tables`，除了限制别的线程的读写外，也限定了本线程接下来的操作对象
- 行锁每次锁定的是一行数据，行级锁定不是MySQL自己实现锁定的方式，是由存储引擎实现的(InnoDB)自己实现的：行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议

### 乐观锁、悲观锁

​    这两个是按照mysql的加锁机制区分的：

- 悲观锁：指的是对数据被外界修改时持保守态度，因此在整个数据处理中将数据处于锁定状态。
- 乐观锁：乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检查，如果发生了冲突，则返回给用户让用户去决定如何去做。

### 共享锁、排他锁

   这两个是按照兼容性区分的：

- 共享锁：允许持有锁，读取行的事务 `SELECT ... LOCK IN SHARE MODE`
- 排他锁：允许持有锁，更新或删除行的事务 `SELECT ... FOR UPDATE`

### 慢查询

​    所有执行时间超过 `long_query_time`秒的查询或不适用于索引的查询，默认为10s。

​    慢查询日子默认名称：`主机名-slow.log`

### 慢查询优化

- 开启慢查询日志，定位到执行较慢的SQL语句
- 利用explain关键字可以模拟优化执行SQL查询语句，来分析SQL查询语句
- 通过查询的结果进行优化
- 优化方式：
    - 分析语句，是否包含了额外的数据
    - 分析优化器中索引的使用情况
    - 如果对语句的优化已经无法执行，可以考虑表中数据是否太大



## 网络编程知识点

### TCP与UDP的区别

- TCP是面向连接的安全传输协议；UDP是面向无连接的不安全传输协议
- TCP尽最大努力交付，提供可靠传输服务；UDP不确保数据会按原来的顺序到达，提供不可靠的创数服务
- TCP首部开销大，为20字节；而UDP首部开销小，只占据8个字节
- TCP只支持点对点通信；而UDP支持一对一、一对多、多对多等场景
- TCP有三次握手四次挥手；UDP没有

### HTTP1.0、1.1、2.0的区别

​    HTTP协议是互联网最广泛的一种网络协议：

- HTTP/1.0规定服务器与客户端只能保持**短暂的连接**，客户端请求建立连接，服务器完成请求释放连接，连接无法复用。TCP连接的建立需要三次握手，是很耗费时间的一个过程。（虽然可以强制开启强链接，但是也不是根本解决办法）
- HTTP/1.1最重要的就是引入了**持久连接**，TCP连接默认不关闭，**可以被多个请求复用**；并且引入了**管道机制**，在同一个TCP中可以客户端可以同时发送多个请求。但是服务端还是顺序执行的，效率还有提升的空间。
- HTTP/2.0进行了**二进制分帧**，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码，所以可以进行**多路复用**，一个连接里，客户端和服务器可以同时发送多个请求和回应，而且不用按顺序一一对应。

### HTTPS是什么？工作流程？

​    是以安全为目标的HTTP通道，升级版的HTTP协议，即HTTP下加入SSL层进行加密：

- 客户端发送自己支持的加密规则给服务器，代表要建立连接
- 服务器从中选出一套加密算法和hash算法以及自己的身份信息以证书的形式发送给浏览器
- 客户端收到证书后要进行以下操作：
    - 验证证书合法性
    - 如果通过，浏览器会产生一串随机数，并用证书中的公钥进行加密
    - 用约定好的hash算法计算握手信息，然后用生成的密钥进行加密，一起发送给服务器
- 服务器接收客户端传来的信息，同时做下面的操作：
    - 用私钥解析出密码，用密码解析握手消息，验证hash值是否和浏览器发来的一致
    - 使用密钥加密消息
- 如果计算的hash值一致，握手成功

### HTTP报文

​    http报文分为请求报文和响应报文两个，每种报文必选特定的格式生成，才能被浏览器端识别，客户端向服务器发送的为请求报文，服务器响应客户端的请求报文发送响应报文。

### 请求报文

​    HTTP请求报文由**请求行、请求头部、空行和请求数据**四个部分组成，其中，**请求分为两中：GET和POST：**

```
GET
 1    GET /562f25980001b1b106000338.jpg HTTP/1.1
 2    Host:img.mukewang.com
 3    User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64)
 4    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
 5    Accept:image/webp,image/*,*/*;q=0.8
 6    Referer:http://www.imooc.com/
 7    Accept-Encoding:gzip, deflate, sdch
 8    Accept-Language:zh-CN,zh;q=0.8
 9    空行
10    请求数据为空
```

```
POST:
1    POST / HTTP1.1
2    Host:www.wrox.com
3    User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR          2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
4    Content-Type:application/x-www-form-urlencoded
5    Content-Length:40
6    Connection: Keep-Alive
7    空行
8    name=Professional%20Ajax&publisher=Wiley
```

- 请求行：用来说明请求类型，要访问的资源以及使用的HTTP版本
- 请求头部：紧接着请求行之后的部分，用来说明服务器的附加信息：
    - HOST，给出请求资源所在服务器的域名
    - User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器定义
    - Accept，说明用户代理可处理的媒体类型
    - Accept-Encoding，说明用户代理支持的内容编码
    - Accept-Language，说明用户代理能够处理的自然语言集
    - Content-Type，说明实现主体的媒体类型
    - Content-Length，说明实现主体的大小
    - Connection，连接管理，可以是Keep-Alive或close
- 空行：请求头部后面的空行是必须的，即使第四部分的请求数据为空，也必须由空行
- 请求数据：也叫主体，可以添加任意的其他数据

### 响应报文

​    HTTP响应报文由四个部分组成，分别是**状态行、消息报头、空行和响应正文**：

```
 1HTTP/1.1 200 OK
 2Date: Fri, 22 May 2009 06:07:21 GMT
 3Content-Type: text/html; charset=UTF-8
 4空行
 5<html>
 6      <head></head>
 7      <body>
 8            <!--body goes here-->
 9      </body>
10</html>
```

- 状态行：由HTTP协议 状态码 状态消息 三部分组成
- 消息报头：用来说明客户端要使用的一些附加信息
- 空行：消息报头后面的空行是必须的
- 响应正文：服务器返回给客户端的文本信息，空行后面的html部分为响应正文

### HTTP状态码

​    分为五类状态码：

- 1xx：表示消息已接受，继续处理
- 2xx：成功，表示消息正常处理完毕
    - 200 OK：客户端请求被正常处理
    - 206 Partial content：客户端进行了范围请求
- 3xx：重定向
    - 301 Moved Permanently：永久重定向，资源已被永久转移到了新的位置，将来任何对资源的访问都要从本响应返回的URL中获得
    - 302 Found：临时重定向，请求的资源现在临时从不同的URL中获得
- 4xx：客户端错误
    - 400 Bad Request：请求报文存在语法错误
    - 403 Forbidden：请求被服务器拒绝
    - 404 Not Found：请求不存在，服务器上找不到请求资源
- 5xx：服务端错误
    - 500 Internal Server Error：服务器在执行请求时出现错误

### GET和POST的区别

- GET主要用向服务器请求数据（查询/获取数据）；POST主要用来向服务器上传数据（提交/修改数据）
- GET方法是显式传参，可以直接在URL上看到参数，以/分割URL和传输的数据；POST是隐式传参，无法直接看到参数
- GET请求会保留在浏览器历史记录中，会被浏览器主动缓存；而POST不会
- GET有长度限制为2KB；POST没有
- GET只支持ASCII字符，而POST没有限制
- GET产生一个TCP数据包：浏览器会把http头部和数据一起发送过去，服务器响应200。POST产生两个TCP数据包：浏览器先发送http头部，告诉服务器我要传数据了，服务器响应100，然后浏览器再发送数据，服务器响应200。网络环境好的情况发送一次TCP包和两次TCP包的时间基本无差。

### cookie与session的区别

- cookie数据存放在浏览器上，session存放在服务器上
- cookie不如session安全
- 单个cookie的限制是3K
- session需要cookie的传递才有意义

### 死锁

​    死锁是两个或两个以上进程之间争夺共享资源而互相等待，如果没有外力则无法产生推进。产生的必要条件有四个：

- 互斥条件
- 请求和保持条件
- 不剥夺条件
- 环路等待条件

​    预防死锁的方法有：

- 有序资源分配法
- 银行家算法：再分配资源前，判断系统是否是安全的；若是安全的才分配。每 分配一次资源就测试一次是否安全，而不是资源全部就位后才测试。

### 进程通信的方式

- 管道pipe：数据只能一个方向流动，有固定的读写端，只能父子或兄弟进程间通信
- 命名管道fifo：和上面差不多，只是可以在非血缘关系进程间通信
- 信号：是一种异步通信的方式
- 消息队列：一个消息的列表，可以把消息看作一个记录，也分读写权限，随着内核持续
- 共享内存：允许两个或多个进程共享物理内存中的同一块区域
- 内存映射：将磁盘文件的数据映射到内存，用户通过修改内存就可以修改磁盘文件
- 信号量：主要解决进程和线程并发执行时的同步问题，对信号量进行P、V操作
- socket套接字：完成不同网络中不同主机进程之间的通信

### 进程和线程的区别

- 进程是资源分配的最小单位；线程是程序执行的最小单元
- 因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。
- 体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便
- 属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同的进程相互独立。
- 线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程

### 进程与线程选择的方法：

- 频繁创建和销毁的优先使用线程，因为创建一个进程的代价比较大
- 线程的切换快，所以在需要大量计算、频繁切换时使用线程
- 并行操作时使用线程，并发响应客户的请求
- 需要安全稳定选择进程，需要速度选择线程

### 守护进程

​     守护进程是一种特殊的进程(孤儿进程)，不受终端控制，守护进程的父进程为init进程。

### 五种I/O模型是什么

- 阻塞I/O：阻塞等待，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，直到数据就绪后才会继续执行
- 非阻塞I/O：非阻塞等待，每隔一段时间去检查I/O是否就绪，没有就继续做自己的事情。
- 信号驱动I/O：内核建立信号的关联并设置回调，当内核有FD就绪时，会发出SIG信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待
- I/O复用：使用select/poll/epoll实现I/O复用，这几个函数会使进程阻塞，这三个函数可以同时阻塞多个I/O操作，而且可以同时对多个写、读I/O事件进行检测，直到数据可读或可写时才进行I/O操作
- 异步I/O

​    上述前四个都是同步I/O。同步I/O是指内核向应用程序通知的是就绪事件，要求用户代码自己执行I/O操作；而异步指内核向应用程序通知的是完成事件，由内核完成I/O操作

### 事件处理模式

- Reactor模式：主线程（I/O单元）只负责监听文件描述符上是否有事件，有的话就通知工作线程（逻辑单元），读写数据、接受新连接及处理客户请求均在逻辑单元完成。通常由同步I/O实现
- Proactor模式：主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责逻辑处理，如处理客户请求。通常由异步I/O实现

### I/O处理与逻辑单元并发编程模式有哪几种？

- 半同步/半异步模式**：同步线程用来处理客户逻辑、异步线程用来处理I/O事件**异步线程监听到客户请求后，就将其封装成请求对象插入请求队列，请求队列通知某个工作在同步模式的工作线程来读取并处理该请求对象。他有一种变体：半同步/半反应堆：
    - 半同步/半反应堆：主线程充当异步线程，负责监听socket上的事件；若有新的请求来，主线程接受，得到新连接的socket，然后往epoll内核事件表中注册该socket的读写事件；如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装为请求对象插入到请求队列
    - 所有工作线程睡眠在请求队列上，当有任务来了，通过竞争（如互斥锁）获得任务的接管权
- 领导者/追随者模式：多个工作线程轮流获得时间源集合，轮流监听、分发并处理事件的一种模式，在任意一个时间点，程序都只有一个领导者

### 池的相关概念

- 池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.
- 空间换时间,浪费服务器的硬件资源,换取运行效率.
- 当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.
- 当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.

### select、poll、epoll的区别

| 系统调用                 | select                       | poll                         | epoll                            |
| ------------------------ | ---------------------------- | ---------------------------- | -------------------------------- |
| **使用的方法**           | 一个1024大小的数组           | 一个自定义大小的集           | 红黑树                           |
| **时间复杂度**           | O(n)                         | O(n)                         | O(1)                             |
| **最大支持文件描述符数** | 一般为1024                   | 65355                        | 65355                            |
| **工作模式**             | LT                           | LT                           | LT/ET                            |
| **内核实现和工作效率**   | 采用轮询方法检测就绪事件O(n) | 采用轮询方法检测就绪事件O(n) | O(n)采用回调方法检测就绪事件O(1) |

- 调用函数
- - select和poll都是一个函数，epoll是一组函数
- 文件描述符数量
- - select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐
        - poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目
        - epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效
- 将文件描述符从用户传给内核
- - select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝
        - epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上
- 内核判断就绪的文件描述符
- select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生
  - epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。
  - epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list
- 应用程序索引就绪文件描述符
- select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历
      - epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可
- 工作模式
- select和poll都只能工作在相对低效的LT模式下
      - epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 
- 应用场景
- 当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll
  - 当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll
  - 当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能

### LT与ET的区别

- LT：水平触发，效率低于ET。只要没有数据被获取，内核就会不断通知你，不用担心事件丢失问题
- ET：边缘触发，在高并发、大流量下会少很多系统调用。一次事件只会触发一次，有变化才会被触发。
- EPOLLONESHOT：一个线程读取某个socket开始处理数据，在处理过程中该socket上又有新的数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket；我们期望一个socket连接在任意一个时刻只被一个线程处理，通过epoll_ctl对该文件描述符注册EPOLLONESHOT事件，一个线程在处理这个socket时独占，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件

### 为什么静态局部变量方法不用加锁？

​    因为static的特性，如果变量在初始化时，并发线程同时进入到static声明语句，并发线程会阻塞等待初始化结束，这样就可以保证在获取静态局部变量的过程一定是初始化后的，所以具有线程安全性，同时避免了new对象时指令重排序造成对象初始化不完全的现象。

### 浏览器从输入URL开始到显示内容中间发生了什么

1. 输入url，按下enter
2. 查看浏览器缓存中是否存在匹配的url，若有则直接显示内容，没有则下一步
3. 进行域名解析，获得相应的ip地址
4. TCP三次握手建立连接
5. 客户端发送HTTP请求报文获取服务器静态资源
6. 服务器发送HTTP响应报文给客户端，客户端获得HTML代码
7. 客户端解析HTML代码并请求HTML代码中的资源
8. 浏览器渲染页面
9. TCP四次挥手关闭连接

### 网络编程的一般步骤

​    TCP

- 服务端：创建socket套接字->绑定端口bind->设置监听上限->接受连接请求accept，返回新的套接字->用返回的套接字进行recv/send->关闭套接字
- 客户端：创建socket套接字->发起建立连接请求connect->recv/send->关闭套接字

​    UDP

- 服务端：创建socket套接字->绑定端口bind->进行recvfrom/sendto->关闭套接字
- 客户端：创建socket套接字->recvfrom/sendto->关闭套接字

### 孤儿进程与僵尸进程

- 孤儿进程一般是由于父进程退出后，他的子进程还在运行，那么这些子进程会成为孤儿进程，被1号进程init进程收养。
- 僵尸进程是由于子进程退出后父进程并没有及时回收它，那么子进程的描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。由于子进程结束后会向父进程发送SIGCHLD信号，所以要防止僵尸进程最好的办法就是让父进程建立一个捕获SIGCHLD的信号处理函数，在函数中调用wait或waitpid函数来回收它。

### 线程同步机制

- 互斥锁
- 信号量：控制同时访问公共资源的线程数量，可以加一减一
- 条件变量

### 线程中的都有哪几种锁？

- 互斥锁：避免多个线程在同一时刻同时操作一个共享资源
- 条件锁(条件变量)：未满足条件时，某个线程会阻塞，当满足时唤醒一个因该条件阻塞的线程，为了防止虚假唤醒，一般放在while循环中，并且通常搭配互斥锁使用
- 自旋锁：如果一个线程想要获得一个被使用的自旋锁，那么他会一直占用CPU请求这个自旋锁使得CPU不能去处理别的事情，直到获取这个锁为止
- 读写锁：读写锁在内部维护了一对相关的锁，一个用于只读的读锁，一个用于只写的写锁

### 什么是惊群效应？

​    惊群效应也有人叫做雷鸣群体效应，简言之，惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。

​    可以使用SO_REUSEPORT特性来解决惊群效应。该特性支持多个线程或进程绑定到同一个端口，提高服务区程序的性能，允许多个套接字bind()及listen()同一个TCP或UDP端口

### Webbench是什么，介绍一下原理？

​    父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。

### 协程

​    线程分为用户态线程和内核态线程两种，协程的本质是处理自身挂起和恢复的用户态线程。协程的切换比线程的切换速度更快，在IO密集的情况下更适合。相比于函数，协程最大的特点就是支持挂起/恢复。

​    按照是否开辟相应的调用栈，协程分为以下两类：

- 有栈协程：每个协程都有自己的调用栈，类似于线程的调用栈
- 无栈协程：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法实现

#### 有栈协程

​    有栈协程会改变函数调用栈，在内存中给每一个协程开辟一个栈空间（存放在堆中），当协程挂起时将他的运行时上下文（即栈空间）从系统栈保存至所分派的栈内存中，当携程恢复时将其运行时上下文从栈内存恢复到系统栈中；他可以在任意函数调用层级的位置进行挂起，并转移调度权。

#### 无栈协程

​    基于状态机的无栈协程解决方案一般是通过状态机记录上次挂起时的位置，并基于此决定恢复时开始执行的位置，这个状态必须存储在栈以外的地方，从而避免状态和栈一同销毁。

​    相比有栈协程，无栈协程不需要修改调用栈，也无需额外内存保存调用栈，开销更小，但是无栈协程的限制比较多，最大的问题就是他无法在任意函数调用层级的位置进行挂起。

### Linux提供的定时方法

- socket的选项SO_RECVTIMEO和SO_SNDTIMEO
- SIGALRM信号
- I/O复用系统调用超时参数

### 网络字节序

​    TCP/TP规定数据流采用大端字节序，即低地址高字节，但是很多设备都是采用小端字节序存储，二者之间通信时需要对数据进行转换，可以调用一下库函数进行网络字节序和主机字节序的转换：

### TCP三次握手

<img src="C:\Users\zhuzhibo\AppData\Roaming\Typora\typora-user-images\image-20230115205049489.png" alt="image-20230115205049489" style="zoom:80%;" />

​    刚开始都是关闭，客户端主动打开，服务器被动打开进入LISTEN状态

- 第一次握手：客户端打开连接，向服务器发送SYN=1的请求报文，seq=x，此后客户端处于SYN_SENT状态
- 第二次握手：服务器返回一个SYN=1，ACK=1，seq=y，ack=x+1的应答报文，此后服务器后处于SYN-RCVD状态，TCP处于半连接状态
- 第三次握手：客户端返回一个ACK=1，seq=x+1，ack=y+1的报文，此时处于established状态，客户端接收到报文后也处于established状态

### 为什么两次请求不行？

​    需要让服务端得知客户端的接受、发送能力正常，服务端自己的接受发送能力正常。并且可以防止历史连接及服务端资源浪费。

### 四次挥手

<img src="C:\Users\zhuzhibo\AppData\Roaming\Typora\typora-user-images\image-20230116151620627.png" alt="image-20230116151620627" style="zoom:80%;" />

- 客户端想要关闭连接，向服务器发送一个FIN=1报文，seq=u，然后进入FIN-WAIT1状态
- 服务器收到客户端发来的FIN报文后，向客户端发送ACK确认报文，此后服务端处于CLOSE-WAIT状态，TCP处在半关闭状态，客户端到服务器的连接释放，客户端进行FIN-WIAT2状态，等待服务器的连接释放报文
- 服务器向客户端发送FIN=1，ACK=1的报文，服务器进入LAST-ACK状态
- 客户端收到服务器的FIN报文，向服务器发送一个ACK报文，此时客户端处于TIME-WAIT状态，需要过2MSL时间后，以保证客户端接收到了自己发送的ACK报文再进入CLOSED状态；服务器接收到客户端发的ACK后彻底CLOSED状态

### 为什么要四次挥手？

​    因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

### 为什么要TIME-WAIT？

​    客户端需要让服务器确保收到自己的ACK报文后再关闭，没有收到的话，服务器会重新发送FIN报文给客户端，然后客户端就知道之前的没有送到，重新发送一个ACK报文。TIME-WAIT的时间至少是一个报文来回的时间。

### TCP保持有效传输拥塞避免的方法

​    采用拥塞控制：

- 慢开始：开始传输先设施一个较低的窗口值cwnd，并且设置一个慢启动阈值，每过一轮RTT（收发时延），就将窗口扩大一倍，直到达到阈值，改为拥塞避免算法
- 拥塞避免：让拥塞窗口cwnd缓慢增大，一个往返时间就把发送方的窗口+1
- 快重传：发送端收到了3个重复的ACK报文，说明发生了丢包，接收端就会立刻发送对方尚未接收的报文段
- 快恢复：发送端收到了3个重复的ACK报文，说明发生了丢包，就进入快恢复阶段：将拥塞窗口阈值降到现在的一半，然后大小变为当前的阈值，然后再线性增加适应

### 滑动窗口

​    TCP 利用滑动窗口实现流量控制的机制。滑动窗口的大小意味着接收方还有多大的缓冲区可以用来接收数据，发送方可以通过滑动窗口大小确定发多少数据，当窗口为0时，发送方一般不发送数据；除非是紧急数据或是发送一个1字节的数据报来通知接收方重新声明它希望接受的下一字节及滑动窗口大小。

### DNS解析的过程

- 主机向本地域名服务器的查询一般采用递归查询：如果主机所询问的本地域名服务器不知道被查寻的域名IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器发出请求查询报文（替主机查询），而不是让主机进行下一步查询。因此递归查询的结果要么就是查寻得IP地址，要么就报错。
- 本地域名服务器向根域名服务器的查询为迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所查询的IP地址，要么就告诉本地服务器你应该下一步去哪个域名服务器查询，让本地自己去查。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。

### OSI七层协议与四层模型

- 应用层：负责给应用程序统一的接口，为应用程序提供交互服务
- 表示层：负责把数据转换成兼容另一个系统能识别的格式
- 会话层：负责建立、管理、终止表示层实体之间的通信会话
- 传输层：负责端到端的数据传输，主要有TCP和UDP两种协议
- 网络层：定义IP地址，定义路由基本功能（包），负责数据的路由、转发、分片
- 数据链路层：负责封装成帧、差错检测
- 物理层：负责底层数据的透明传输（比特流）

​    四层模型是一个实现的应用模型，由7层简化而来

- 应用层：负责向用户提供一组应用程序，如HTTP、DNS、FTP等
- 传输层：负责端到端的通信，比如TCP、UDP等
- 网络层：负责网络包的封装、分片、路由，比如IP，ICMP等
- 网络接口层：负责物理网络中的传输，封装成帧、差错寻址以及网卡传输网络