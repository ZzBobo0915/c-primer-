## 网络编程知识点

### TCP与UDP的区别

- TCP是面向连接的安全传输协议；UDP是面向无连接的不安全传输协议
- TCP尽最大努力交付，提供可靠传输服务；UDP不确保数据会按原来的顺序到达，提供不可靠的创数服务
- TCP首部开销大，为20字节；而UDP首部开销小，只占据8个字节
- TCP只支持点对点通信；而UDP支持一对一、一对多、多对多等场景
- TCP有三次握手四次挥手；UDP没有

### HTTP1.1、1.1、2.0的区别

​    HTTP协议是互联网最广泛的一种网络协议：

- HTTP/1.0规定服务器与客户端只能保持**短暂的连接**，客户端请求建立连接，服务器完成请求释放连接，连接无法复用。TCP连接的建立需要三次握手，是很耗费时间的一个过程。（虽然可以强制开启强链接，但是也不是根本解决办法）
- HTTP/1.1最重要的就是引入了**持久连接**，TCP连接默认不关闭，**可以被多个请求复用**；并且引入了**管道机制**，在同一个TCP中可以客户端可以同时发送多个请求。但是服务端还是顺序执行的，效率还有提升的空间。
- HTTP/2.0进行了**二进制分帧**，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码，所以可以进行**多路复用**，一个连接里，客户端和服务器可以同时发送多个请求和回应，而且不用按顺序一一对应。

### HTTPS是什么？工作流程？

​    是以安全为目标的HTTP通道，升级版的HTTP协议，即HTTP下加入SSL层进行加密：

- 客户端发送自己支持的加密规则给服务器，代表要建立连接
- 服务器从中选出一套加密算法和hash算法以及自己的身份信息以证书的形式发送给浏览器
- 客户端收到证书后要进行以下操作：
    - 验证证书合法性
    - 如果通过，浏览器会产生一串随机数，并用证书中的公钥进行加密
    - 用约定好的hash算法计算握手信息，然后用生成的密钥进行加密，一起发送给服务器
- 服务器接收客户端传来的信息，同时做下面的操作：
    - 用私钥解析出密码，用密码解析握手消息，验证hash值是否和浏览器发来的一致
    - 使用密钥加密消息
- 如果计算的hash值一致，握手成功

### HTTP报文

​    http报文分为请求报文和响应报文两个，每种报文必选特定的格式生成，才能被浏览器端识别，客户端向服务器发送的为请求报文，服务器响应客户端的请求报文发送响应报文。

### 请求报文

​    HTTP请求报文由**请求行、请求头部、空行和请求数据**四个部分组成，其中，**请求分为两中：GET和POST：**

```
GET
 1    GET /562f25980001b1b106000338.jpg HTTP/1.1
 2    Host:img.mukewang.com
 3    User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64)
 4    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
 5    Accept:image/webp,image/*,*/*;q=0.8
 6    Referer:http://www.imooc.com/
 7    Accept-Encoding:gzip, deflate, sdch
 8    Accept-Language:zh-CN,zh;q=0.8
 9    空行
10    请求数据为空
```

```
POST:
1    POST / HTTP1.1
2    Host:www.wrox.com
3    User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR          2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
4    Content-Type:application/x-www-form-urlencoded
5    Content-Length:40
6    Connection: Keep-Alive
7    空行
8    name=Professional%20Ajax&publisher=Wiley
```

- 请求行：用来说明请求类型，要访问的资源以及使用的HTTP版本
- 请求头部：紧接着请求行之后的部分，用来说明服务器的附加信息：
    - HOST，给出请求资源所在服务器的域名
    - User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器定义
    - Accept，说明用户代理可处理的媒体类型
    - Accept-Encoding，说明用户代理支持的内容编码
    - Accept-Language，说明用户代理能够处理的自然语言集
    - Content-Type，说明实现主体的媒体类型
    - Content-Length，说明实现主体的大小
    - Connection，连接管理，可以是Keep-Alive或close
- 空行：请求头部后面的空行是必须的，即使第四部分的请求数据为空，也必须由空行
- 请求数据：也叫主体，可以添加任意的其他数据

### 响应报文

​    HTTP响应报文由四个部分组成，分别是**状态行、消息报头、空行和响应正文**：

```
 1HTTP/1.1 200 OK
 2Date: Fri, 22 May 2009 06:07:21 GMT
 3Content-Type: text/html; charset=UTF-8
 4空行
 5<html>
 6      <head></head>
 7      <body>
 8            <!--body goes here-->
 9      </body>
10</html>
```

- 状态行：由HTTP协议 状态码 状态消息 三部分组成
- 消息报头：用来说明客户端要使用的一些附加信息
- 空行：消息报头后面的空行是必须的
- 响应正文：服务器返回给客户端的文本信息，空行后面的html部分为响应正文

### HTTP状态码

​    分为五类状态码：

- 1xx：表示消息已接受，继续处理
- 2xx：成功，表示消息正常处理完毕
    - 200 OK：客户端请求被正常处理
    - 206 Partial content：客户端进行了范围请求
- 3xx：重定向
    - 301 Moved Permanently：永久重定向，资源已被永久转移到了新的位置，将来任何对资源的访问都要从本响应返回的URL中获得
    - 302 Found：临时重定向，请求的资源现在临时从不同的URL中获得
- 4xx：客户端错误
    - 400 Bad Request：请求报文存在语法错误
    - 403 Forbidden：请求被服务器拒绝
    - 404 Not Found：请求不存在，服务器上找不到请求资源
- 5xx：服务端错误
    - 500 Internal Server Error：服务器在执行请求时出现错误

### GET和POST的区别

- GET主要用向服务器请求数据（查询/获取数据）；POST主要用来向服务器上传数据（提交/修改数据）
- GET方法是显式传参，可以直接在URL上看到参数，以/分割URL和传输的数据；POST是隐式传参，无法直接看到参数
- GET请求会保留在浏览器历史记录中，会被浏览器主动缓存；而POST不会
- GET有长度限制为2KB；POST没有
- GET只支持ASCII字符，而POST没有限制
- GET产生一个TCP数据包：浏览器会把http头部和数据一起发送过去，服务器响应200。POST产生两个TCP数据包：浏览器先发送http头部，告诉服务器我要传数据了，服务器响应100，然后浏览器再发送数据，服务器响应200。网络环境好的情况发送一次TCP包和两次TCP包的时间基本无差。

### 死锁

​    死锁是两个或两个以上进程之间争夺共享资源而互相等待，如果没有外力则无法产生推进。产生的必要条件有四个：

- 互斥条件
- 请求和保持条件
- 不剥夺条件
- 环路等待条件

​    预防死锁的方法有：

- 有序资源分配法
- 银行家算法：再分配资源前，判断系统是否是安全的；若是安全的才分配。每 分配一次资源就测试一次是否安全，而不是资源全部就位后才测试。

### 进程通信的方式

- 管道pipe：数据只能一个方向流动，有固定的读写端，只能父子或兄弟进程间通信
- 命名管道fifo：和上面差不多，只是可以在非血缘关系进程间通信
- 信号：是一种异步通信的方式
- 消息队列：一个消息的列表，可以把消息看作一个记录，也分读写权限，随着内核持续
- 共享内存：允许两个或多个进程共享物理内存中的同一块区域
- 内存映射：将磁盘文件的数据映射到内存，用户通过修改内存就可以修改磁盘文件
- 信号量：主要解决进程和线程并发执行时的同步问题，对信号量进行P、V操作
- socket套接字：完成不同网络中不同主机进程之间的通信

### 进程和线程的区别

- 进程是资源分配的最小单位；线程是程序执行的最小单元
- 进程拥有独立的堆栈空间和数据段；线程拥有独立的堆栈空间，但是共享数据段；
- 进程之间通信互不打扰，相互独立，通信需要借助各种手段；线程由于共享数据段所以通信方式很方便
- 进程并发性较低；线程并发行较高
- 每个进程都有一个程序运行的入口、程序执行序列和程序的出口；而线程不能够独立执行，必须依托在应用程序中

### 五种I/O模型是什么

- 阻塞I/O：阻塞等待，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，直到数据就绪后才会继续执行
- 非阻塞I/O：非阻塞等待，每隔一段时间去检查I/O是否就绪，没有就继续做自己的事情。
- 信号驱动I/O：内核建立信号的关联并设置回调，当内核有FD就绪时，会发出SIG信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待
- I/O复用：使用select/poll/epoll实现I/O复用，这几个函数会使进程阻塞，这三个函数可以同时阻塞多个I/O操作，而且可以同时对多个写、读I/O事件进行检测，直到数据可读或可写时才进行I/O操作
- 异步I/O

​    上述前四个都是同步I/O。同步I/O是指内核向应用程序通知的是就绪事件，要求用户代码自己执行I/O操作；而异步指内核向应用程序通知的是完成事件，由内核完成I/O操作

### 事件处理模式

- Reactor模式：主线程（I/O单元）只负责监听文件描述符上是否有事件，有的话就通知工作线程（逻辑单元），读写数据、接受新连接及处理客户请求均在逻辑单元完成。通常由同步I/O实现
- Proactor模式：主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责逻辑处理，如处理客户请求。通常由异步I/O实现

### I/O处理与逻辑单元并发编程模式有哪几种？

- 半同步/半异步模式**：同步线程用来处理客户逻辑、异步线程用来处理I/O事件**异步线程监听到客户请求后，就将其封装成请求对象插入请求队列，请求队列通知某个工作在同步模式的工作线程来读取并处理该请求对象。他有一种变体：半同步/半反应堆：
    - 半同步/半反应堆：主线程充当异步线程，负责监听socket上的事件；若有新的请求来，主线程接受，得到新连接的socket，然后往epoll内核事件表中注册该socket的读写事件；如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装为请求对象插入到请求队列
    - 所有工作线程睡眠在请求队列上，当有任务来了，通过竞争（如互斥锁）获得任务的接管权
- 领导者/追随者模式：多个工作线程轮流获得时间源集合，轮流监听、分发并处理事件的一种模式，在任意一个时间点，程序都只有一个领导者

### 池的相关概念

- 池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.
- 空间换时间,浪费服务器的硬件资源,换取运行效率.
- 当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.
- 当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.

### select、poll、epoll的区别

| 系统调用                 | select                       | poll                         | epoll                            |
| ------------------------ | ---------------------------- | ---------------------------- | -------------------------------- |
| **使用的方法**           | 一个1024大小的数组           | 一个自定义大小的集           | 红黑树                           |
| **时间复杂度**           | O(n)                         | O(n)                         | O(1)                             |
| **最大支持文件描述符数** | 一般为1024                   | 65355                        | 65355                            |
| **工作模式**             | LT                           | LT                           | LT/ET                            |
| **内核实现和工作效率**   | 采用轮询方法检测就绪事件O(n) | 采用轮询方法检测就绪事件O(n) | O(n)采用回调方法检测就绪事件O(1) |

- 调用函数

- - select和poll都是一个函数，epoll是一组函数

- 文件描述符数量

- - select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐
    - poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目
    - epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效

- 将文件描述符从用户传给内核

- - select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝
    - epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上

- 内核判断就绪的文件描述符

- - select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生
    - epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。
    - epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list

- 应用程序索引就绪文件描述符

- - select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历
    - epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可

- 工作模式

- - select和poll都只能工作在相对低效的LT模式下
    - epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 

- 应用场景

- - 当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll
    - 当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll
    - 当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能

### LT与ET的区别

- LT：水平触发，效率低于ET。只要没有数据被获取，内核就会不断通知你，不用担心事件丢失问题
- ET：边缘触发，在高并发、大流量下会少很多系统调用。一次事件只会触发一次，有变化才会被触发。
- EPOLLONESHOT：一个线程读取某个socket开始处理数据，在处理过程中该socket上又有新的数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket；我们期望一个socket连接在任意一个时刻只被一个线程处理，通过epoll_ctl对该文件描述符注册EPOLLONESHOT事件，一个线程在处理这个socket时独占，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件

### 浏览器从输入URL开始到显示内容中间发生了什么

1. 输入地址，浏览器查找域名的ip地址
2. TCP三次握手建立连接
3. 客户端发送HTTP请求报文获取服务器静态资源
4. 服务器发送HTTP响应报文给客户端，客户端获得页面静态资源
5. TCP四次挥手关闭连接
6. 浏览器解析文档资源并渲染页面

### 网络编程的一般步骤

​    TCP

- 服务端：创建socket套接字->绑定端口bind->设置监听上限->接受连接请求accept，返回新的套接字->用返回的套接字进行recv/send->关闭套接字
- 客户端：创建socket套接字->发起建立连接请求connect->recv/send->关闭套接字

​    UDP

- 服务端：创建socket套接字->绑定端口bind->进行recv/send->关闭套接字
- 客户端：创建socket套接字->recvfrom/sendto->关闭套接字

### 孤儿进程与僵尸进程

- 孤儿进程一般是由于父进程退出后，他的子进程还在运行，那么这些子进程会成为孤儿进程，被1号进程init进程收养。
- 僵尸进程是由于子进程退出后父进程并没有及时回收它，那么子进程的描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。由于子进程结束后会向父进程发送SIGCHLD信号，所以要防止僵尸进程最好的办法就是让父进程建立一个捕获SIGCHLD的信号处理函数，在函数中调用wait或waitpid函数来回收它。

### 线程同步机制

- 互斥锁
- 信号量：控制同时访问公共资源的线程数量，可以加一减一
- 条件变量

### 线程中的都有哪几种锁？

- 互斥锁：避免多个线程在同一时刻同时操作一个共享资源
- 条件锁(条件变量)：未满足条件时，某个线程会阻塞，当满足时唤醒一个因该条件阻塞的线程，为了防止虚假唤醒，一般放在while循环中，并且通常搭配互斥锁使用
- 自旋锁：如果一个线程想要获得一个被使用的自旋锁，那么他会一直占用CPU请求这个自旋锁使得CPU不能去处理别的事情，直到获取这个锁为止
- 读写锁：读写锁在内部维护了一对相关的锁，一个用于只读的读锁，一个用于只写的写锁

### 什么是惊群效应？

​    惊群效应也有人叫做雷鸣群体效应，简言之，惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。

​    可以使用SO_REUSEPORT特性来解决惊群效应。该特性支持多个线程或进程绑定到同一个端口，提高服务区程序的性能，允许多个套接字bind()及listen()同一个TCP或UDP端口

### Webbench是什么，介绍一下原理？

​    父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。

### Linux提供的定时方法

- socket的选项SO_RECVTIMEO和SO_SNDTIMEO
- SIGALRM信号
- I/O复用系统调用超时参数

### 网络字节序

​    TCP/TP规定数据流采用大端字节序，即低地址高字节，但是很多设备都是采用小端字节序存储，二者之间通信时需要对数据进行转换，可以调用一下库函数进行网络字节序和主机字节序的转换：

### TCP三次握手

<img src="C:\Users\zhuzhibo\AppData\Roaming\Typora\typora-user-images\image-20230115205049489.png" alt="image-20230115205049489" style="zoom:80%;" />

​    刚开始都是关闭，客户端主动打开，服务器被动打开进入LISTEN状态

- 第一次握手：客户端打开连接，向服务器发送SYN=1的请求报文，seq=x，此后客户端处于SYN_SENT状态
- 第二次握手：服务器返回一个SYN=1，ACK=1，seq=y，ack=x+1的应答报文，此后服务器后处于SYN-RCVD状态，TCP处于半连接状态
- 第三次握手：客户端返回一个ACK=1，seq=x+1，ack=y+1的报文，此时处于established状态，客户端接收到报文后也处于established状态

### 为什么两次请求不行？

​    需要让服务端得知客户端的接受、发送能力正常，服务端自己的接受发送能力正常

### 四次挥手

<img src="C:\Users\zhuzhibo\AppData\Roaming\Typora\typora-user-images\image-20230116151620627.png" alt="image-20230116151620627" style="zoom:80%;" />

- 客户端想要关闭连接，向服务器发送一个FIN=1报文，seq=u，然后进入FIN-WAIT1状态
- 服务器收到客户端发来的FIN报文后，向客户端发送ACK确认报文，此后服务端处于CLOSE-WAIT状态，TCP处在半关闭状态，客户端到服务器的连接释放，客户端进行FIN-WIAT2状态，等待服务器的连接释放报文
- 服务器向客户端发送FIN=1，ACK=1的报文，服务器进入LAST-ACK状态
- 客户端收到服务器的FIN报文，向服务器发送一个ACK报文，此时客户端处于TIME-WAIT状态，需要过2MSL时间后，以保证客户端接收到了自己发送的ACK报文再进入CLOSED状态；服务器接收到客户端发的ACK后彻底CLOSED状态

### 为什么要四次挥手？

​    因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

### 为什么要TIME-WAIT？

​    客户端需要让服务器确保收到自己的ACK报文后再关闭，没有收到的话，服务器会重新发送FIN报文给客户端，然后客户端就知道之前的没有送到，重新发送一个ACK报文。TIME-WAIT的时间至少是一个报文来回的时间。

### TCP保持有效传输拥塞避免的方法

​    采用拥塞控制：

- 慢开始：开始传输先设施一个较低的窗口值cwnd，并且设置一个慢启动阈值，每过一轮RTT（收发时延），就将窗口扩大一倍，直到达到阈值，改为拥塞避免算法
- 拥塞避免：让拥塞窗口cwnd缓慢增大，一个往返时间就把发送方的窗口+1
- 快重传：发送端收到了3个重复的ACK报文，说明发生了丢包，接收端就会立刻发送对方尚未接收的报文段
- 快恢复：发送端收到了3个重复的ACK报文，说明发生了丢包，就进入快恢复阶段：将拥塞窗口阈值降到现在的一半，然后大小变为当前的阈值，然后再线性增加适应

### 滑动窗口

​    TCP 利用滑动窗口实现流量控制的机制。滑动窗口的大小意味着接收方还有多大的缓冲区可以用来接收数据，发送方可以通过滑动窗口大小确定发多少数据，当窗口为0时，发送方一般不发送数据；除非是紧急数据或是发送一个1字节的数据报来通知接收方重新声明它希望接受的下一字节及滑动窗口大小。

### DNS解析的过程

- 主机向本地域名服务器的查询一般采用递归查询：如果主机所询问的本地域名服务器不知道被查寻的域名IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器发出请求查询报文（替主机查询），而不是让主机进行下一步查询。因此递归查询的结果要么就是查寻得IP地址，要么就报错。
- 本地域名服务器向根域名服务器的查询为迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所查询的IP地址，要么就告诉本地服务器你应该下一步去哪个域名服务器查询，让本地自己去查。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。

### 七层协议与四层模型

- 物理层：底层数据传输（比特流）
- 数据链路层：定义数据的基本格式，如何传输，如何表示（帧）
- 网络层：定义IP地址，定义路由基本功能（包）
- 运输层：端到端传输数据的基本功能（段）
- 会话层：控制应用程序之间的会话能力
- 表示层：数据格式表示，基本压缩功能加密
- 应用层：各种应用软件

​    四层模型是一个实现的应用模型，由7层简化而来
