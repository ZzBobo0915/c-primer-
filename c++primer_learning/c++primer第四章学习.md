# c++primer学习

## 第4章 表达式

#### 4.1 基础

##### 1.左值和右值

​    c++的表达式要不然就是右值，要不就是左值；左值可以位于赋值语句的左侧，右值不可以。

​    **ps：当一个对象被用做右值的的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。**

-  赋值运算符需要一个(非常量)左值作为其左侧运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
-  取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
-  内置解引用运算符、下标运算符、迭代器解引用运算符、string和string的下标运算符的求值结果都是左值。
-  内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。

##### 2.处理复合表达式

- 拿不准的时候最好用括号类强制让表达式的组合关系复核程序逻辑的要求。
- 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。

#### 4.2 算术运算符

​    按照运算符优先等级进行分组：

![4-1](E:\朱智博-文件杂项\c++\c++primer学习图片\4-1.png)

#### 4.3 逻辑和关系运算符

​    对于这两类运算符来说，运算对象和求值结果都是右值：

![4-2](E:\朱智博-文件杂项\c++\c++primer学习图片\4-2.png)

​    **ps：进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为对象。**

#### 4.4 赋值运算符

​    赋值运算符的左侧运算对象必须是一个可修改的左值：

```c++
int i =0, j = 0, k =0;  //初始化而非赋值
const int ci = i;       //初始化而非赋值
1024 = k;               //错误：字面值是右值
i + j = k;              //错误：算术表达式右值
ci = k;                 //错误：ci是不可修改的左值
```

​    赋值运算符蛮子右结合律，这一点和其他二元运算符不太一样：

```c++
int ival, jval;   
ival = jval = 0;  //正确：都被赋值为0
```

​    **ps：因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。**

#### 4.5 递增和递减运算符

​    递增运算符++和递减运算符--分为前置版本和后置版本：

```c++
int i = 0, j;
j = ++i;  //j=1，i=1：前置版本得到递增后的值
j = i++;  //j=1，i=2：后置版本得到递增前的值
```

​    **ps：除非必须，否则不要使用后置版本的递增递减运算符。**

#### 4.6 成员访问运算符

​    点运算符(.)和箭头运算符(->)都可以用于访问成员：

```c++
string s1 = "a string", *p = &s1;
auto n = s1.size();
n = (*p).size();  //因为解引用运算符的优先级低于点运算符，所以加括号
n = p->size();
```

#### 4.7 条件运算符

​    条件运算符(?:)允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：

`cond ? expr1 : expr2;`

#### 4.8 位运算符

![4-3](E:\朱智博-文件杂项\c++\c++primer学习图片\4-3.png)

​    **ps：关于符号位如何处理没有明确的规定，所以强烈建议位运算符用于处理无符号类型。**

#### 4.9 sizeof运算符

​    sizeof运算符返回一条表达式或一个类型名字所占的字节数。满足右结合律。

- 对数组执行sizeof运算得到整个数组所占空间的大小。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针所指向对象所占空间的大小。

#### 4.10 逗号运算符

​    逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。通常被用在for循环当中。

#### 4.11 类型转换

​    在C++语言中，某些类型之间有关联。如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代。换句话说，如果两种类型可以相互转换（conversion），那么它们就是关联的。

##### 1.隐式转换

`int ival = 3.541 + 2;  //编译器可能会警告运算失去了精度`

​    上述的类型转换是自动执行的，无需程序员介入，因此被称为**隐式转换**。常见的隐式转换如下：

- 整型提升：把小整数类型转换为较大的整数类型。
- 无符号运算和有符号类型的运算中有符号类型会被隐式转化为无符号类型。
- 数组转换为指针
- 类类型定义的转换

##### 2.显式转换

​    有时我们希望显式地强制转换某一种类型，比如：

```c++
int i, j;
double slope = i / j;  //强制转换i/j为double类型
```

​    一个命名的强制转换具有以下形式：

```c++
cast-name<type>(expression);
```

- type：转换的目标类型

- expression：要转换的值

- cast-name：是static_cast, dynamic_cast, const_cast和reinterpret中的一种：

  - static_cast：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

  `double slope = static_cast<double> (j) / i;`

  - const_cast：只能改变运算对象的底层const(一般被称为去掉const性质)。

  `const char *pc;` 

  ``double *dp = const_cast<char*>(pc); ``

  - reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。
  - dynamic_cast支持运行时类型识别。

  ​