# c++primer学习

## 第3章 字符串、向量和数组

#### 3.1 命名空间的using声明

​    有了using声明就无需专门的前缀（形如命名空间::）也能使用所需的名字了，using声明具有以下的形式：

​    `using namespace::name;`

​    **ps：按照规定，每个using声明只引入命名空间的一个成员，一行可以放置多条using语句，记得用分号;分开。头文件不应包含using声明**

#### 3.2 标准库类型string

​    标准库类型string表示可变长的字符序列，使用必须包含头文件string。

```c++
#include<string>
using std::string;
```

##### 1.定义和初始化string对象

![3-1](E:\朱智博-文件杂项\c++\c++primer学习图片\3-1.png)

##### 2.直接初始化和拷贝初始化

​    如果使用 = 初始化一个对象，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去；与之相反，则执行的是直接初始化。

```c++
string s5 = "hiya";  //拷贝初始化
string s6("hiya");   //直接初始化
string s7(10, 'c');  //直接初始化
```

##### 3.string对象上的操作

```c++
os << s;         //将s写到输出流os中，返回os
is >> s;         //从is中读取字符串赋给s，返回is
getline(is, s);  //从is中读取一行赋给s，返回is
s.empty();       //判断s是否为空，返回bool
s.size();        //返回s中的字符个数
s[n];            //返回s中的第n个字符，从0开始计数
```

-  getline函数返回的那个换行符被丢弃掉了，得到的string对象中并不包含这个换行符。
- 对于size函数来说，实际上它返回的是一个string::size_type类型的值。

##### 4.处理string对象中的字符

​    在cctype头文件中定义了一组标准库函数处理这部分工作：

![3-2](E:\朱智博-文件杂项\c++\c++primer学习图片\3-2.png)

​    ps：使用c++版本的c标准库头文件，一般应该使用cname的头文件而不是name.h的形式。

```c++
#include<cctype>   //c++
#include<ctype.h>  //c
```

#### 3.3 标准库类型vector

   标准库类型**vector**表示对象的集合，其中所有对象的类型都相同。因为vector容纳着其他对象，所以它也被称作**容器**。使用时也要包含头文件 **#include<vector>**

​    ps：vector是模板而不是容器，由vector生成的类型必须包含vector中元素的类型，例如vevtor<int>。

##### 1.定义和初始化vector

``` c++
vector<T> v1;                 //v1是一个空的vector，执行默认初始化
vector<T> v2(v1);             //v2中包含v1所有元素的副本
vevtor<T> v2 = v1;            //等价于v2(v1)，v2中包含v1所有元素的副本
vector<T> v3(n, val);         //v3包含了n个重复的val
vector<T> v4(n);              //v4包含了n个重复地执行了值初始化的对象
vector<T> v5{a, b, c...};     //v5包含了初始值个数的元素，每个元素赋予相应的初始值
vector<T> v6 = {a, b, c...};  //等价于v5{a, b, c...}
```

##### 2.其他vector操作

```c++
v.empty();       //判断v是否为空，返回bool
v.size();        //返回v中元素个数
v.push_back(t);  //向v的尾端添加元素t
v[n];            //放回v中第n个元素的引用，从0开始计数
```

​    **ps：不能使用下标形式添加元素，只能对确认已存在的元素执行下标操作！**

#### 3.4 迭代器

​    迭代器是另一种可以访问容器元素的机制。

##### 1.使用迭代器

​    和指针不一样，获取迭代器不是使用的取地址符，有迭代器类型同时拥有返回迭代器的成员。比如这些类型都拥有名为**begin**和**end**的成员，其中begin成员负责返回会指向第一个元素的迭代器，end成员则负责返回指向容器的“为元素的下一个位置”，指向一个不存在的“尾后”元素。

```c++
auto b = v.begin();
auto e = v.end();
```

​    **ps：如果容器为空，则begin和end返回的是同一个迭代器，都是为后迭代器。**

##### 2.迭代器运算符

```c++
*iter      //返回迭代器iter所指元素的运算符
iter->mem  //解引用iter并获取该元素名为men的成员，等价于(*iter).mem
++iter     //令iter指向容器中的下一个元素
--iter     //令iter指向容器中的上一个元素
```

##### 3.迭代器类型

​    一般使用iterator和const_iterator来表示迭代器的类型：

```c++
vector<int>::iterator it;         //it能读写容器中的元素
vector<int>::const_iterator it2;  //it2只能读元素，不能写元素
```

​    **ps：begin和end返回的具体类型有对象是否为常量决定：**

```c++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();   //it1类型为iterator
auto it2 = cv.begin();  //it2类型为const_iterator
```

​    结合解引用和成员访问操作：c++语言定义了**箭头运算符（->）**将解引用和成员访问结合到一起，也就是说，(*it).mem与it->men的表达意思相同。

##### 4.迭代器运算

![3-3](E:\朱智博-文件杂项\c++\c++primer学习图片\3-3.png)

#### 3.5 数组

​    数组也是存放相同类型对象的容器，但是数组大小确定不变，不能随意向数组中添加元素。

##### 1.定义和初始化内置数组

​    数组是一种复合类型，生命形式如a[d]，a为名字，d为维度且必须是一个常量表达式。

​    **ps：定义数组必须指定数组的类型和大小。不允许使用auto来推断类型，且和vector一样，数组的元素应为对象，因此不存在引用的数组。**

##### 2.数组和指针

​    使用数组的时候编译器一般会把它转换成指针。在很多用到数组名字的地方，编译器会自动的将其替换为一个指向数组首元素的指针。

```c++
string num[] = {"ont", "two", "three"};  //数组元素是string对象
string *p = &num[0];                     //p指向nums的第一个元素
string *q = num;                         //等价于q = &num[0];
```

​    **ps：大多情况下，使用数组类型的对象其实是使用一个指向该数组首元素的指针。**

​    数组的指针也是迭代器，也支持迭代器的操作：

```c++
int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *p = arr;  //p指向arr的第一个元素
++p;           //p指向arr[1]
```

##### 3.标准库函数begin和end

​    c++11新标准引入了两个名为begin和end的函数，和容器中的两个重名成员功能类似，定义在头文件iteraoter中。将数组作为参数，返回指针：

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);  //指向ia首元素的指针
int *last = end(ia);   //指向arr尾元素的下一个位置的指针
```

​    **ps：尾后指针不能解引用和递增。**

##### 4.C风格字符串

​    定义在头文件cstring中，cstring是C语言头文件string.h的c++版本：

```
strlen(p)       //返回p的长度，空字符不计算
strcmp(p1, p2)  //比较p1和p2是否相等，返回0/1
strcat(p1, p2)  //将p2附加到p1之后，返回p1
strcpy(p1, p2)  //将p2拷贝到p1，返回p1
```

​    **ps：传入此类函数的指针必须指向空字符作为结束的数组。**

#### 3.6 多维数组

​    通常来说多维数组就是数组的数组。

`int ia[3][4];  //大小为3的数组，每个元素是含有4个整数的数组`

##### 1.指针与多维数组

​    编译器会自动将其转换为指向数组首元素的指针：

```
int ia[3][4];
int (*p)[4] = ia;  //p指向含有4个整数的数组
p = &ia[2];        //p指向ia的尾元素
```

​    **ps：(*p)[4]的圆括号()必不可少。**