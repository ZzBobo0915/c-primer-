# c++primer学习

## 第6章 函数

#### 6.1 函数基础

​    一个经典的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。

##### 1.调用函数

​    函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。

##### 2.形参和实参

​    实参是形参的初始值。实参的类型必须与对应的形参类型匹配。

##### 3.函数的形参列表

​    函数的形参列表可以为空，但是不能省略，也可使用关键字void表示函数没有形参：

```c++
void f1() { }      //隐式地定义空形参列表
void f2(void) { }  //显式地定义空形参列表
```

##### 4.局部对象

​    在c++中，名字有作用域，对象有生命周期。形参和函数体内部定义的变量统称为局部变量。同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。

​    **ps：静态局部对象在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁。**

##### 5.函数声明

​    和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。

```c++
void func(int, int);  //函数定义只需要包含返回类型、函数名、形参类型就可以
```

​    ps：含有函数声明的头文件应该包含到函数定义的源文件中。

#### 6.2 参数传递

- 当形参是引用类型时，对应的实参被称作引用传递。
- 当实参的值是拷贝给形参时，我们成为值传递。

##### 1.传值参数

​    值传递不会改变实参的值，而引用传递会因为改变形参的值而使实参的值改变。

​    **ps：c++中建议使用引用类型的形参代替指针。**

##### 2.传引用参数

​    如果函数无需改变引用形参的值，最好将其声明为常量引用。

```c++
bool judge(const int x1, const int x2){  //函数不涉及改变引用形参的值
    return x1 == x2;
}
```

##### 3.const形参和实参

​    当用实参初始化形参师会忽略掉顶层const。

```c++
void func(const int i){ }
void func(int i) {}  //错误：重复定义了func(int)
```

##### 4.数组形参

​    当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

```c++
//以下三个print函数是等价的
void print(const int*);
void print(const int[]);
void print(const int[10]);  //表示我们想传入一个10个元素的数组，但实际不一定
```

​    传递多维数组：

```c++
void print(int (*matrix)[10], int rowSize);
```

##### 5.含有可变形参的函数

​    c++11提供两种方法来处理编写不同数量实参的函数：

- 如果实参的类型不同，我们可以编写可变参数模板函数。
- 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型。

![6-1](E:\朱智博-文件杂项\c++\c++primer学习图片\6-1.png)

​    和vector一样，initializer_list也是一种模板类型；但和vector不一样，initializer_list对象中的元素永远是常量值，无法修改其中元素的值。

```c++
initializer_list<string> ls;
void error_msg(initializer_list<string> il){
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << ' ';
}
```

#### 6.3 返回类型和return语句

##### 1.return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。

```c++
return;             //只能用在返回类型为void的函数中
return expression;  //提供了返回结果的return
```

​    **ps：在含有return的语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的。**

- 不要返回局部对象的引用或指针
- 调用一个返回引用的函数得到左值，其他返回类型得到右值。

##### 2.返回数组指针

​    因为数组不能被拷贝，所以函数不能返回数组。不过可以返回数组的指针或者引用。

​    c++中引入了尾置返回类型来简化声明一个返回数组指针：

```
auto func(int i) -> int(*)[10];
```

​    还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype 关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个∶ 

```c++
int ood[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
decltype(odd) *arrPtr(int i){  //decltype表示返回类型为和odd相同的类型，但是他不负责把数组类型转换为相应的指针，所以要返回指针就要加*
    return (i % 2) ? &odd : &even;
}
```

#### 6.4 函数重载

